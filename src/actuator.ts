import ActuatorImpl from "./actuatorImpl";
import SubscriptionImpl from "./subscription";

/**
 * All messages require an identifier.
 * The identifier should be serializable so messages can be persisted.
 */
export type AnyMsg = { readonly type: string };

/**
 * An updater receives messages to be processed by the state generator.
 */
export type Updater<M extends AnyMsg> = (msg: M) => void;

/**
 * An update function can return new state plus message(s) to send.
 * If the state change is `undefined`, the message will be passed to the outbound message handler.
 */
export type StateChange<Model, Msg extends AnyMsg> = Model | [Model, ...Promise<Msg>[]] | undefined;

type Subscription<Msg extends AnyMsg> = SubscriptionImpl<Msg>;

/**
 * If a subscription needs to clean up external event listeners or intervals,
 * it can return a function to be called when the subscription is removed.
 */
type Unsubscriber = () => void;

/**
 * The subscription's implementation function. The `updater` provides
 * a means for the subscription to send messages dervied from external events.
 * @param updater Actuator's updater
 */
export type Subscriber<M extends AnyMsg> = (updater: Updater<M>) => undefined | Unsubscriber;

/**
 * The functions necessary to implement a stateful component that can
 * process messages.
 */
export interface ModelProvider<Model, Msg extends AnyMsg, Context> {
  /**
   * Creates the initial state.
   * Context is provided to allow models to generate state based on other data sources.
   */
  init(context: Context): StateChange<Model, Msg>;
  /**
   * Converts messages into new models.
   * Can also return messages to be sent asynchronously, enabling
   * state changes based on network responses or other async activity.
   */
  update(model: Model, msg: Msg, context: Context): StateChange<Model, Msg> | undefined;
  /**
   * Provides a mechanism to generate messages based on an asynchronous API.
   * It's called on every model update.
   */
  subscribe?(model: Model, context: Context): Subscription<Msg>;
  /**
   * Return the current context for use in update processing.
   * Context is useful for providing access to other state that is not managed
   * by `state-actuator`.
   */
  context?(): Context;
}

/**
 * Use this constant in `update` functions to specify one or more messages should
 * be handled as outbound messages. These messages will be passed to the actuator's
 * `outboundMsgHandler` function.
 */
export const AS_OUTBOUND_MSG = undefined;

/**
 * The core implementation
 */
export interface StateActuator<Model, Msg extends AnyMsg> {
  /**
   * The state when the actuator is created.
   */
  readonly initialModel: Readonly<Model>;

  /**
   * The updater recevies messages generated by the application.
   */
  readonly updater: Updater<Msg>;

  /**
   * The updater that receives messages not handled by this actuator.
   */
  outboundMsgHandler?: Updater<AnyMsg>;

  /**
   * Return a new iterator over state changes.
   * Multiple iterators can be created and work in parallel.
   */
  stateIterator(): AsyncIterableIterator<Model>;

  /**
   * Close down the actuator such that the iterator will become "done".
   * Any pending messages are ignored and model updates stop.
   */
  close(): void;
}

/**
 * Create a state actuator given the state definition
 * @param provider Functions to implement the state management lifecycle
 * @returns The actuator implementation
 */
export function StateActuator<Model, Msg extends AnyMsg, Context>(
  provider: ModelProvider<Model, Msg, Context>
): StateActuator<Model, Msg> {
  return new ActuatorImpl(provider);
}

/**
 * Test a value to see if it implements the 'AnyMsg' structure.
 */
export function isActuatorMsg(param: any): param is AnyMsg {
  return typeof param === "object" && "type" in param;
}

/**
 * Create a object to manage the lifetime of the given subscription function.
 * @param subscriber The implementation of the subscriber
 * @param keys (optional) controls whether a new instance replaces the current
 * @returns The subscription record
 */
export function Subscription<Msg extends AnyMsg>(
  subscriber: Subscriber<Msg>,
  keys?: Array<any>
): Subscription<Msg> {
  return new SubscriptionImpl(subscriber, keys);
}
